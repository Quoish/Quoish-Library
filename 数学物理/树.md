#数据结构
树是一种非线性的数据结构，它是由n个有限结点组成有层次关系的集合。![[树.png]]
树具有以下特点，可以根据这些特点来判断一个数据结构是否是树：
- 每个结点具有0个或多个子结点
- 每个子结点只有一个父结点
- 没有前驱的结为根结点
- 除了根结点外，每个子结点又可以由m棵不相关的子树组成
# 相关术语
- 结点的度：结点拥有的子树数量称为结点的度
- 树的度：树内各结点度的最大值，即上图D结点的度就是此树的度
- 叶子：度为0的节点称为吐子或终端节点
- 结点的层次和树的深度
- 森林：m棵互不相交的树的集合
![[树结点的度.png]]
# 二叉树
二叉树与树主要有以下区别：
1. 二叉树每个结点至多只有两棵子树（即二叉树中不能存在度大于2的结点）
2. 二叉树的子树有左右之分，其次序不能任意颠倒
3. 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树
## 二叉树的性质
二叉树的性质：
1. 在二叉树的第i层上至多有$2i-1$个结点（$i\geq1$）
2. 深度为k的二叉树至多有$2k-1$个结点（$k\geq1$）
3. 对任何一棵二叉树$T$，如果其终端结点数为$n_{0}$，度为2的结点数为$n_{2}$，则$n_{0}=n_{2}+1$

---
证明：
一棵二叉树，除了终端结点（叶子结点），就是度为1或2的结点。
假设n1表示度为1的结点数，则树$T$的结点总数$n=n_{0}+n_{1}+n_{2}$，我们再换个角度，看一下树T的连接线数，除了根节点，其他结点都有一根线表示分支进入，所以连接线数为结点总数减去1。
按连接线树算的话：$n-1=n_{1}+2n_{2}$，可推导出$n_{0}+n_{1}+n_{2}-1=n_{1}+2n_{2}$，继续推导可得$n_{0}=n_{2}+1$
## 完全二叉树
如下图，对一颗具有$n$个结点的二叉树按层序编号，如果编号为$i$（$1\leq i\leq n$）的结点与同样深度的满二叉树中编号为$i$的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。
![[完全二叉树.png]]
性质：
- 叶子结点只能出现在最下面两层
- 最下层的叶子一定集中在左部连续位置
- 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况
- 同样结点数的二叉树，完全二叉树的深度最小
- 具有$n$个节点的完全二叉树深度为$\lfloor \log_{2} n \rfloor +1$
- 如果对一颗有n个结点的完全二叉树（其深度为$\lfloor \log_{2} n \rfloor +1$）的结点按层序编号（从第1层到第
$\lfloor \log_{2} n \rfloor +1$层，每层从左到右），对任一结点$i$($1\leq j\leq n$)有：
	*1.* 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]
	*2.* 如果2i>n，则结点i无孩子（结点i为叶子结点）；否则其左孩子是结点2i
	*3.* 如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1
## 二叉树的存储
### 顺式存储
即按照层序编号，以数组依次存储数据。
二叉树的顺序存储结构缺点很明显：不能反应逻辑关系；对于特殊的二叉树（左斜树、右斜树），浪费存储空间。
所以二叉树顺序存储结构一般只用于完全二叉树。
### 列表之列表
这是python独有的特殊储存方式。
![[二叉树示例.png]]
```python
my_tree = [a,  
            [b,  
                [d, [], []],  
                [e, [], []],  
            ],  
            [c,  
                [f, [], []],  
                []  
            ],  
          ]
```
插入左子树
```python
def insert_left(root, new_branch):  
    if root is None:  
        return  
    tmp = root.pop(1) # 把要插入的旧左子树弹出  
    if len(tmp) > 1:  
        root.insert(1, [new_branch, tmp, []]) # 若旧左子树有东西，就拿去做新左子树的左子树  
    else:  
        root.insert(1, [new_branch, [], []]) # 若旧左子树没有东西，就直接插入左子树
```
右子树类似。
### 链式存储
```python
class Binary_Tree(object):  
    def __init__(self, root):  
        self.root = root  
        self.left = None  
        self.right = None
```
## 二叉树的遍历
二叉树的遍历：按某条搜索路径访问二叉树中每一个结点，使得每个结点被访问一次且仅被访问一次。
遍历方法有4种：先序遍历，中序遍历，后序遍历，层次遍历。
### 先序遍历
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树
```python
# 先序遍历（针对链式存储）
def traveling_tree(tree):  
    print(tree.data)  
    if tree.left:  
        traveling_tree(tree.left)  
    if tree.right:  
        traveling_tree(tree.right)
```
### 中序遍历
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树
### 后序遍历
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点
### 层序遍历
按层次（1到$k$层），每层从左到右依次访问二叉树中的每一个结点。
# Huffman树
## 树的带权路径
- 路径：从一个结点到另一个结点之间的分支序列
- 路径长度：从一个结点到另一个结点所经过的分支数目
- 结点的权$w_{k}$：根据应用的需要可以给树的结点赋权值
- 结点的带权路径长度$l_{k}$：从根到该结点的路径长度与该结点权的乘积
- 树的带权路径长度$\sum_{k}w_{k}l_{k}$：树中所有叶子结点的带权路径之和
## Huffman树的构造
哈夫曼（Huffman）树：由n个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树
Huffman树的构造基于贪心算法。
假设有$n$个权值，则构造出的哈夫曼树有$n$个叶子结点。$n$个权值分别设为$w_{1}、w_{2}、…、w_{n}$，则哈夫曼树的构造规则为：
1. 将$w_{1}、w_{2}、…、w_{n}$看成是有$n$棵树的森林(每棵树仅有一个结点)；
2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
3. 从森林中删除选取的两棵树，并将新树加入森林；
4. 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。
示例：
```python
def build_huffman_tree(leaves):# 入参leaves，是一个0度二叉树构成的列表  
    if len(leaves) == 1:  
        return leaves[0]  
    leaves.sort(key = lambda x: x.data)  
    tree = BinaryTree(0)  
    tree.data = leaves[0].data + leaves[1].data  
    tree.insert_left(leaves.pop(0))  
    tree.insert_right(leaves.pop(0))  
    leaves.append(tree) # 将合成的二叉树塞入叶列表，参与下一步的排序  
    huffman_tree = build_huffman_tree(leaves)  
    return huffman_tree
```
## Huffman编码
前缀码：如果在七个编码系统中，任一个编码都不是其他任何编码的前缀，则称该编码系统中的编码是前缀码。
例如，一组编码01, 001, 010, 100，110就不是前缀码，因为01是010的前缀，若去掉01或010就是前缀码。
Huffman编码：对一棵具有$n$个叶子的Huffman树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的通路上，各分支的赋值分别构成一个二进制串，该二进制串就称为Huffman编码。
Huffman编码即是最优前缀码。
